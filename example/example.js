var EuclideanMST = require("../euclideanmst.js");
var Delaunay = require("delaunay");

function printVert( V )
{
  for (var ind in V)
  {
    console.log( V[ind][0] + " " + V[ind][1] );
  }
}

function printEdge( V, E )
{
  for (var e in E)
  {
    var u = E[e][0];
    var v = E[e][1];

    console.log( V[u][0] + " " + V[u][1] );
    console.log( V[v][0] + " " + V[v][1] );
    console.log("");
  }
}

// Generate an example 'random enough' sequence
//
var n = 3000;
var verts = [];
for (var i=0; i<n; i++)
{
  var a = 123.12315;
  var b = 7788.1231;
  var p = [ (Math.cos( a*(i+1) ) + 1.0)/2.0, (Math.cos( b*(i+1) ) + 1.0)/2.0 ];
  verts.push(p);
}

// In case we want to see the edges generated by the Euclidean MST algorithm,
// generate teh Delaunay triangulation and convert them to edges so we can print
// them out.  They're provided here for illustrative purpose.
//
var triangles = Delaunay.triangulate(verts);
var triangleEdges = [];
for (var i=0; i<triangles.length; i+=3)
{
  var e = [ triangles[i], triangles[i+1] ];
  triangleEdges.push(e);

  e = [ triangles[i], triangles[i+2] ];
  triangleEdges.push(e);

  e = [ triangles[i+1], triangles[i+2] ];
  triangleEdges.push(e);
}

function distance_metric(a,b) 
{
  return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]); 
}

var edges = EuclideanMST.euclideanMST( verts, distance_metric  );


//printVert( verts );
//printEdge( verts, triangleEdges );

printEdge( verts, edges );

